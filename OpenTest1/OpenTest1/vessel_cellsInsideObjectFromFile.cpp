//#include <string>  
//#include <json.h>
//#include <iostream>  
//#include <fstream> 
//#include <cstdlib>
//#include <vector> 
//#include <stack>
//
//#include "vtkSmartPointer.h"
//#include "vtkActor.h"
//#include "vtkCamera.h"
//#include "vtkCellArray.h"
//#include "vtkPoints.h"
//#include "vtkPolyData.h"
//#include "vtkPointData.h"
//#include "vtkPolyDataMapper.h"
//#include "vtkRenderWindow.h"
//#include "vtkRenderWindowInteractor.h"
//#include "vtkRenderer.h" 
//#include "vtkProperty.h"
//#include "vtkTubeFilter.h"
//#include "vtkDoubleArray.h"
//#include "vtkParametricSpline.h"
//#include "vtkParametricFunctionSource.h"
//#include "vtkTupleInterpolator.h"
//#include "vtkIntersectionPolyDataFilter.h"
//#include "vtkAssembly.h"
//#include "vtkOBJExporter.h"
//#include <vtkDataSetMapper.h>
//#include <vtkMultiBlockDataSet.h>
//#include <vtkMultiThreshold.h>
//#include <vtkNamedColors.h>
//#include <vtkNew.h>
//#include <vtkSelectEnclosedPoints.h>
//#include <vtkTransform.h>
//#include <vtkTransformPolyDataFilter.h>
//#include <vtkUnstructuredGrid.h>
//#include <vtkPolyDataReader.h>
//#include <vtkSphereSource.h>
//#include <vtksys/SystemTools.hxx>
//#include <vtkOBJReader.h>
//#include <vtkAppendPolyData.h>
//#include <vtkCellArray.h>
//#include <vtkDataSetSurfaceFilter.h>
//#include <vtkPointSource.h>
//#include <vtkUnstructuredGrid.h>
//#include <vtkUnstructuredGridReader.h>
//#include <vtkVertex.h>
//#include <vtkAutoInit.h> 
//VTK_MODULE_INIT(vtkRenderingOpenGL2);
//VTK_MODULE_INIT(vtkInteractionStyle);
//VTK_MODULE_INIT(vtkRenderingFreeType)
//
//
//vtkSmartPointer<vtkPolyData> ReadPolyData(const char* fileName);
//vtkSmartPointer<vtkPolyData> myFunc(vtkSmartPointer<vtkPolyData>input1, vtkSmartPointer<vtkPolyData>input2, vtkSmartPointer<vtkRenderer>renderer);
//vtkSmartPointer<vtkAppendPolyData> appendFilter = vtkSmartPointer<vtkAppendPolyData>::New();
//
//int main(int argc, char* argv[])
//{
//	//‰÷»æ≥°æ∞
//	vtkSmartPointer<vtkRenderer> renderer =
//		vtkSmartPointer<vtkRenderer>::New();
//	vtkSmartPointer<vtkRenderWindow> renderWindow =
//		vtkSmartPointer<vtkRenderWindow>::New();
//	renderWindow->AddRenderer(renderer);
//	vtkSmartPointer<vtkRenderWindowInteractor> renderWindowInteractor =
//		vtkSmartPointer<vtkRenderWindowInteractor>::New();
//	renderWindowInteractor->SetRenderWindow(renderWindow);
//
//	vtkSmartPointer<vtkPolyData> polyData1 = ReadPolyData("D:\\Program_Files\\vtk\\vessel_model\\20211122\\vesselKid1.obj");
//	vtkSmartPointer<vtkPolyData> polyData2 = ReadPolyData("D:\\Program_Files\\vtk\\vessel_model\\20211122\\vesselKid2.obj");
//	vtkSmartPointer<vtkPolyData> polyData3 = ReadPolyData("D:\\Program_Files\\vtk\\vessel_model\\20211122\\vesselKid3.obj");
//	vtkSmartPointer<vtkPolyData> polyData4 = ReadPolyData("D:\\Program_Files\\vtk\\vessel_model\\20211122\\vesselKid4.obj");
//	vtkSmartPointer<vtkPolyData> polyData5 = ReadPolyData("D:\\Program_Files\\vtk\\vessel_model\\20211122\\vesselKid5.obj");
//
//	//appendFilter->AddInputData(polyData1);
//	vtkSmartPointer<vtkPolyData> p = myFunc(polyData2, polyData1, renderer);
//	vtkSmartPointer<vtkPolyData> q = myFunc(polyData1, polyData2, renderer);
//	appendFilter->AddInputData(p);
//	appendFilter->AddInputData(q);
//	//myFunc(polyData2, polyData1, renderer);
//	//myFunc(appendFilter, polyData2, renderer);
//
//	appendFilter->Update();
//	vtkSmartPointer<vtkPolyDataMapper> mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
//	mapper->SetInputData(appendFilter->GetOutput());
//	//mapper->SetInputData(polyData1);
//	mapper->ScalarVisibilityOff();
//
//	vtkSmartPointer<vtkActor>actor = vtkSmartPointer<vtkActor>::New();
//	actor->SetMapper(mapper); 
//	actor->GetProperty()->SetColor(1, 0.09, 0.20);
//	actor->GetProperty()->SetRepresentationToWireframe();
//
//	//renderer->AddActor(actor);
//
//	renderer->SetBackground(.2, .3, .4);
//	renderWindow->SetSize(800, 800);
//	renderWindow->Render();
//	renderWindowInteractor->Start();
//
//	return EXIT_SUCCESS;
//}
//vtkSmartPointer<vtkPolyData> myFunc(vtkSmartPointer<vtkPolyData>input1, vtkSmartPointer<vtkPolyData>input2, vtkSmartPointer<vtkRenderer>renderer) {
//	vtkNew<vtkSelectEnclosedPoints> select;
//	select->SetInputData(input1);
//	select->SetSurfaceData(input2);
//
//	vtkNew<vtkMultiThreshold> threshold;
//	// Outside points have a 0 value in ALL points of a cell
//	int outsideId = threshold->AddBandpassIntervalSet(
//		0, 0, vtkDataObject::FIELD_ASSOCIATION_POINTS, "SelectedPoints", 0, 1);
//	// Inside points have a 1 value in ALL points of a cell
//	int insideId = threshold->AddBandpassIntervalSet(
//		1, 1, vtkDataObject::FIELD_ASSOCIATION_POINTS, "SelectedPoints", 0, 1);
//	// Border points have a 0 or a 1 in at least one point of a cell
//	int borderId = threshold->AddIntervalSet(
//		0, 1, vtkMultiThreshold::OPEN, vtkMultiThreshold::OPEN,
//		vtkDataObject::FIELD_ASSOCIATION_POINTS, "SelectedPoints", 0, 0);
//
//	threshold->SetInputConnection(select->GetOutputPort());
//
//	// Select the intervals to be output
//	threshold->OutputSet(outsideId);
//	threshold->OutputSet(insideId);
//	threshold->OutputSet(borderId);
//	threshold->Update();
//
//
//	// Visualize
//	vtkNew<vtkNamedColors> colors;
//	vtkColor3d outsideColor = colors->GetColor3d("Crimson");
//	vtkColor3d insideColor = colors->GetColor3d("Banana");
//	vtkColor3d borderColor = colors->GetColor3d("Crimson");
//	vtkColor3d surfaceColor = colors->GetColor3d("Peacock");
//	vtkColor3d backgroundColor = colors->GetColor3d("Silver");
//
//	// Outside
//	vtkNew<vtkDataSetMapper> outsideMapper;
//	outsideMapper->SetInputData(dynamic_cast<vtkUnstructuredGrid*>(
//		vtkMultiBlockDataSet::SafeDownCast(
//			threshold->GetOutput()->GetBlock(outsideId))
//		->GetBlock(0)));
//	outsideMapper->ScalarVisibilityOff();
//
//	vtkNew<vtkActor> outsideActor;
//	outsideActor->SetMapper(outsideMapper);
//	outsideActor->GetProperty()->SetDiffuseColor(outsideColor.GetData());
//	outsideActor->GetProperty()->SetSpecular(.6);
//	outsideActor->GetProperty()->SetSpecularPower(30);
//	//outsideActor->GetProperty()->SetOpacity(.1);
//	outsideActor->GetProperty()->SetRepresentationToWireframe();
//
//	// Border
//	vtkNew<vtkDataSetMapper> borderMapper;
//	borderMapper->SetInputData(dynamic_cast<vtkUnstructuredGrid*>(
//		vtkMultiBlockDataSet::SafeDownCast(
//			threshold->GetOutput()->GetBlock(borderId))
//		->GetBlock(0)));
//	borderMapper->ScalarVisibilityOff();
//
//	vtkNew<vtkActor> borderActor;
//	borderActor->SetMapper(borderMapper);
//	borderActor->GetProperty()->SetDiffuseColor(borderColor.GetData());
//	borderActor->GetProperty()->SetSpecular(.6);
//	borderActor->GetProperty()->SetSpecularPower(30);
//	borderActor->GetProperty()->EdgeVisibilityOn();
//	//borderActor->GetProperty()->SetOpacity(0);
//	borderActor->GetProperty()->SetRepresentationToWireframe();
//
//	vtkSmartPointer<vtkAppendPolyData> append = vtkSmartPointer<vtkAppendPolyData>::New();
//
//	auto outsideFilter = vtkSmartPointer<vtkDataSetSurfaceFilter>::New();
//	outsideFilter->SetInputData(dynamic_cast<vtkUnstructuredGrid*>(
//		vtkMultiBlockDataSet::SafeDownCast(
//			threshold->GetOutput()->GetBlock(outsideId))
//		->GetBlock(0)));
//	vtkSmartPointer<vtkPolyData> outside = outsideFilter->GetOutput();
//	append->AddInputData(outside);
//
//	auto borderFilter = vtkSmartPointer<vtkDataSetSurfaceFilter>::New();
//	borderFilter->SetInputData(dynamic_cast<vtkUnstructuredGrid*>(
//		vtkMultiBlockDataSet::SafeDownCast(
//			threshold->GetOutput()->GetBlock(borderId))
//		->GetBlock(0)));
//	vtkSmartPointer<vtkPolyData> border = borderFilter->GetOutput();
//	append->AddInputData(border);
//	append->Update();
//
//	vtkSmartPointer<vtkPolyDataMapper> mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
//	mapper->SetInputData(append->GetOutput());
//	//mapper->SetInputData(polyData1);
//	mapper->ScalarVisibilityOff();
//
//	vtkSmartPointer<vtkActor>actor = vtkSmartPointer<vtkActor>::New();
//	actor->SetMapper(mapper);
//	actor->GetProperty()->SetColor(1, 0.09, 0.20);
//	actor->GetProperty()->SetRepresentationToWireframe();
//
//	renderer->AddActor(actor);
//
//
//	return append->GetOutput();
//	//renderer->AddActor(surfaceActor);
//	//renderer->AddActor(outsideActor);
//	//renderer->AddActor(insideActor);
//	//renderer->AddActor(borderActor);
//
//}
//
//vtkSmartPointer<vtkPolyData> ReadPolyData(const char* fileName)
//{
//	vtkSmartPointer<vtkPolyData> polyData;
//	vtkNew<vtkOBJReader> reader;
//	reader->SetFileName(fileName);
//	reader->Update();
//	polyData = reader->GetOutput();
//	return polyData;
//}