//#include <vtkCamera.h>
//#include <vtkExtractSurface.h>
//#include <vtkMinimalStandardRandomSequence.h>
//#include <vtkNamedColors.h>
//#include <vtkNew.h>
//#include <vtkPCANormalEstimation.h>
//#include <vtkPointData.h>
//#include <vtkPointSource.h>
//#include <vtkPolyDataMapper.h>
//#include <vtkProperty.h>
//#include <vtkRenderWindow.h>
//#include <vtkRenderWindowInteractor.h>
//#include <vtkRenderer.h>
//#include <vtkSignedDistance.h>
//#include <vtkSmartPointer.h>
//#include "vtkCellArray.h"
//#include "vtkPoints.h"
//#include "vtkPolyData.h"
//#include "vtkTubeFilter.h"
//#include "vtkDoubleArray.h"
//#include "vtkParametricSpline.h"
//#include "vtkParametricFunctionSource.h"
//#include "vtkTupleInterpolator.h"
//#include "vtkIntersectionPolyDataFilter.h"
//#include "vtkAssembly.h"
//#include "vtkOBJExporter.h"
//#include "vtkAppendPolyData.h"
//#include "vtkCellLocator.h"
//#include "vtkNamedColors.h"
//#include "vtkPolyDataConnectivityFilter.h"
//#include "vtkTriangleFilter.h"
//
//#include <vtksys/SystemTools.hxx>
//
//#include <vtkBYUReader.h>
//#include <vtkOBJReader.h>
//#include <vtkPLYReader.h>
//#include <vtkPolyDataReader.h>
//#include <vtkSTLReader.h>
//#include <vtkXMLPolyDataReader.h>
//
//#include <string>  
//#include <json.h>
//#include <iostream>  
//#include <fstream> 
//#include <cstdlib>
//#include <vector> 
//
//#include <vtkAutoInit.h> 
//VTK_MODULE_INIT(vtkRenderingOpenGL2);
//VTK_MODULE_INIT(vtkInteractionStyle);
//VTK_MODULE_INIT(vtkRenderingFreeType)
//
//using namespace std;
//
//
//class Branch;
//class Branch
//{
//public:
//	double radius = 0;
//	bool isShow = false;
//	vector<Branch> children;
//	vector<int> childenId;
//	int kidLen = 0;
//	vector<int> pos;
//	int posLen = 0;
//};
//
//vector<Branch> readFileJson();
//
//int main(int argc, char* argv[])
//{
//	//血管数据
//	vector<Branch> branches = readFileJson();
//
//	//血管模型建立
//	vtkSmartPointer<vtkAppendPolyData> appendFilter =
//		vtkSmartPointer<vtkAppendPolyData>::New();
//
//	for (int i = 0; i < branches.size(); i++) {
//		if (branches[i].isShow == false) {
//			vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();
//			int indexPos = 0;
//			double rad;
//			vtkSmartPointer<vtkTupleInterpolator> interpolatedRadius =
//				vtkSmartPointer<vtkTupleInterpolator> ::New();
//			interpolatedRadius->SetInterpolationTypeToLinear();
//			interpolatedRadius->SetNumberOfComponents(1);
//			int indexRad = 0;
//			bool flag = true;
//			Branch* target = &branches[i];
//			while (flag) {
//				target->isShow = true;
//				rad = target->radius; interpolatedRadius->AddTuple(indexRad++, &rad);
//				rad = target->radius; interpolatedRadius->AddTuple(indexRad++, &rad);
//				for (int j = 0; j < target->posLen; j += 2) {
//					points->InsertPoint(indexPos++, target->pos[j + 1], target->pos[j], 0);
//				}
//				if (target->kidLen != 0 && branches[target->childenId[0]].isShow == false) {
//					target = &branches[target->childenId[0]];
//				}
//				else {
//					flag = false;
//				}
//			}
//			vtkSmartPointer<vtkParametricSpline> spline = vtkSmartPointer<vtkParametricSpline>::New();
//			spline->SetPoints(points);
//			vtkSmartPointer<vtkParametricFunctionSource> functionSource =
//				vtkSmartPointer<vtkParametricFunctionSource>::New();
//			functionSource->SetParametricFunction(spline);
//			functionSource->SetUResolution(10 * points->GetNumberOfPoints());
//			functionSource->Update();
//
//			vtkSmartPointer<vtkDoubleArray> tubeRadius =
//				vtkSmartPointer<vtkDoubleArray>::New();
//			unsigned int n = functionSource->GetOutput()->GetNumberOfPoints();
//			std::cout << "n:" << n;
//			tubeRadius->SetNumberOfValues(n);
//			tubeRadius->SetName("TubeRadius");
//			double tMin = interpolatedRadius->GetMinimumT(); std::cout << "tMin:" << tMin;
//			double tMax = interpolatedRadius->GetMaximumT(); std::cout << "tMax:" << tMax;
//			double r;
//			for (unsigned int i = 0; i < n; ++i)
//			{
//				double t = (tMax - tMin) / (n - 1) * i + tMin;
//				interpolatedRadius->InterpolateTuple(t, &r);
//				tubeRadius->SetTuple1(i, r);
//			}
//
//			vtkSmartPointer<vtkPolyData> tubePolyData =
//				vtkSmartPointer<vtkPolyData>::New();
//			tubePolyData = functionSource->GetOutput();
//			tubePolyData->GetPointData()->AddArray(tubeRadius);
//			tubePolyData->GetPointData()->SetActiveScalars("TubeRadius");
//
//			vtkSmartPointer<vtkTubeFilter> tuber =
//				vtkSmartPointer<vtkTubeFilter>::New();
//			tuber->SetInputData(tubePolyData);
//			tuber->SetNumberOfSides(50);
//			tuber->SetVaryRadiusToVaryRadiusByAbsoluteScalar();
//			tuber->SetCapping(true);
//
//			appendFilter->AddInputConnection(tuber->GetOutputPort());
//		}
//
//		vtkSmartPointer<vtkPolyDataMapper> tubeMapper =
//			vtkSmartPointer<vtkPolyDataMapper>::New();
//		tubeMapper->SetInputConnection(appendFilter->GetOutputPort());
//		tubeMapper->ScalarVisibilityOff();
//
//		vtkSmartPointer<vtkActor> tubeActor = vtkSmartPointer<vtkActor>::New();
//		tubeActor->SetMapper(tubeMapper);
//		tubeActor->GetProperty()->SetColor(1, 0.09, 0.20);
//		tubeActor->GetProperty()->SetRepresentationToWireframe();
//
//
//		auto polyData = appendFilter->GetOutput();
//
//		std::cout << "# of points: " << polyData->GetNumberOfPoints() << std::endl;
//
//		double bounds[6];
//		polyData->GetBounds(bounds);
//		double range[3];
//		for (int i = 0; i < 3; ++i)
//		{
//			range[i] = bounds[2 * i + 1] - bounds[2 * i];
//		}
//
//		int sampleSize = polyData->GetNumberOfPoints() * 0.00005;
//		if (sampleSize < 10)
//		{
//			sampleSize = 10;
//		}
//		std::cout << "Sample size is: " << sampleSize << std::endl;
//		// Do we need to estimate normals?
//		vtkNew<vtkSignedDistance> distance;
//		if (polyData->GetPointData()->GetNormals())
//		{
//			std::cout << "Using normals from input file" << std::endl;
//			distance->SetInputData(polyData);
//		}
//		else
//		{
//			std::cout << "Estimating normals using PCANormalEstimation" << std::endl;
//			vtkNew<vtkPCANormalEstimation> normals;
//			normals->SetInputData(polyData);
//			normals->SetSampleSize(sampleSize);
//			normals->SetNormalOrientationToGraphTraversal();
//			normals->FlipNormalsOn();
//			distance->SetInputConnection(normals->GetOutputPort());
//		}
//		std::cout << "Range: " << range[0] << ", " << range[1] << ", " << range[2]
//			<< std::endl;
//		int dimension = 256;
//		double radius;
//		radius = std::max(std::max(range[0], range[1]), range[2]) /
//			static_cast<double>(dimension) * 4; // ~4 voxels
//		std::cout << "Radius: " << radius << std::endl;
//
//		distance->SetRadius(radius);
//		distance->SetDimensions(dimension, dimension, dimension);
//		distance->SetBounds(bounds[0] - range[0] * .1, bounds[1] + range[0] * .1,
//			bounds[2] - range[1] * .1, bounds[3] + range[1] * .1,
//			bounds[4] - range[2] * .1, bounds[5] + range[2] * .1);
//
//		vtkNew<vtkExtractSurface> surface;
//		surface->SetInputConnection(distance->GetOutputPort());
//		surface->SetRadius(radius * .99);
//		surface->Update();
//
//		vtkNew<vtkPolyDataMapper> surfaceMapper;
//		surfaceMapper->SetInputConnection(surface->GetOutputPort());
//		surfaceMapper->ScalarVisibilityOff();
//
//		vtkNew<vtkNamedColors> colors;
//
//		vtkNew<vtkProperty> back;
//		back->SetColor(colors->GetColor3d("Banana").GetData());
//
//		vtkNew<vtkActor> surfaceActor;
//		surfaceActor->SetMapper(surfaceMapper);
//		surfaceActor->GetProperty()->SetColor(colors->GetColor3d("Tomato").GetData());
//		surfaceActor->SetBackfaceProperty(back);
//		surfaceActor->GetProperty()->SetRepresentationToWireframe();
//
//		// Create graphics stuff
//		//
//		vtkNew<vtkRenderer> ren1;
//		ren1->SetBackground(colors->GetColor3d("SlateGray").GetData());
//
//		vtkNew<vtkRenderWindow> renWin;
//		renWin->AddRenderer(ren1);
//		renWin->SetSize(512, 512);
//		renWin->SetWindowName("ExtractSurface");
//
//		vtkNew<vtkRenderWindowInteractor> iren;
//		iren->SetRenderWindow(renWin);
//
//		// Add the actors to the renderer, set the background and size
//		//
//		ren1->AddActor(surfaceActor);
//
//		// Generate an interesting view
//		//
//		ren1->ResetCamera();
//		ren1->GetActiveCamera()->Azimuth(120);
//		ren1->GetActiveCamera()->Elevation(30);
//		ren1->GetActiveCamera()->Dolly(1.0);
//		ren1->ResetCameraClippingRange();
//
//		renWin->Render();
//		iren->Initialize();
//		iren->Start();
//
//		return EXIT_SUCCESS;
//	}
//}
//
//vector<Branch> readFileJson()
//{
//	Json::Reader reader;
//	Json::Value root;
//
//	vector<Branch> tempbranches;
//
//	//从文件中读取，保证当前文件有branches.json文件  
//	ifstream in("D:\\Program_Files\\OpenCV\\Projects\\OpenCVTest1Img\\branches.json", ios::binary);
//
//	if (!in.is_open())
//	{
//		cout << "Error opening file\n";
//		return tempbranches;
//	}
//
//	if (reader.parse(in, root))
//	{
//		//读取数组信息  
//		int numBranch = root["lines"].size();
//		vector<Branch> branches(numBranch);
//
//		for (int i = 0; i < numBranch; i++)
//		{
//			//cout << root["lines"][i] << endl;
//			Branch node;
//			int len = root["lines"][i].size();
//			int step = 10;
//			int newlen = 0;
//			int j1 = 0;
//			for (j1; j1 < len; j1 += step) {
//				newlen += 2;
//			}
//			if (j1 - 10 != len - 1) {
//				newlen += 2;
//			}
//			node.posLen = newlen;
//			vector<int> p(newlen);
//			int index = 0;
//			int j = 0;
//			for (j; j < len; j += step) {
//				for (unsigned int k = 0; k < root["lines"][i][j].size(); k++) {
//					p[index++] = root["lines"][i][j][k].asInt();
//				}
//			}
//			if (j - 10 != len - 1) {
//				for (unsigned int k = 0; k < root["lines"][i][len - 1].size(); k++) {
//					p[index++] = root["lines"][i][len - 1][k].asInt();
//				}
//			}
//			node.pos = p;
//			branches[i] = node;
//		}
//
//		for (int i = 0; i < numBranch; i++) {
//			int s = branches[i].posLen;
//			int kidlen = 0;
//			for (int j = 0; j < numBranch; j++) {
//				if (j != i &&
//					(branches[j].pos[0] >= branches[i].pos[s - 2] - 5) &&
//					(branches[j].pos[0] <= branches[i].pos[s - 2] + 5) &&
//					(branches[j].pos[1] >= branches[i].pos[s - 1] - 5) &&
//					(branches[j].pos[1] <= branches[i].pos[s - 1] + 5))
//				{
//					kidlen++;
//					branches[i].children.push_back(branches[j]);
//					branches[i].childenId.push_back(j);
//				}
//			}
//			branches[i].kidLen = kidlen;
//		}
//
//		//有问题
//		branches[0].radius = 20;
//		branches[1].radius = 15;
//		branches[2].radius = 15;
//		branches[3].radius = 11.25;
//		branches[4].radius = 8.4375;
//		branches[5].radius = 11.25;
//		branches[6].radius = 8.4375;
//		branches[7].radius = 8.4375;
//		branches[8].radius = 8.4375;
//
//		for (int i = 0; i < numBranch; i++) {
//			int numKid = branches[i].kidLen;
//			for (int j = 0; j < numKid; j++) {
//				branches[i].children[j].radius = branches[i].radius / numKid * 1.5;
//			}
//		}
//
//		//cout << "Reading Complete!" << endl;
//		return branches;
//	}
//	else
//	{
//		cout << "parse error\n" << endl;
//	}
//
//	in.close();
//
//	return tempbranches;
//}