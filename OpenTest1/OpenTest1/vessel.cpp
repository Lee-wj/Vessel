//#include <string>  
//#include <json.h>
//#include <iostream>  
//#include <fstream> 
//#include <cstdlib>
//#include <vector> 
//#include <stack>
//
//#include "vtkSmartPointer.h"
//#include "vtkActor.h"
//#include "vtkCamera.h"
//#include "vtkCellArray.h"
//#include "vtkPoints.h"
//#include "vtkPolyData.h"
//#include "vtkPointData.h"
//#include "vtkPolyDataMapper.h"
//#include "vtkRenderWindow.h"
//#include "vtkRenderWindowInteractor.h"
//#include "vtkRenderer.h" 
//#include "vtkProperty.h"
//#include "vtkTubeFilter.h"
//#include "vtkDoubleArray.h"
//#include "vtkParametricSpline.h"
//#include "vtkParametricFunctionSource.h"
//#include "vtkTupleInterpolator.h"
//#include "vtkIntersectionPolyDataFilter.h"
//#include "vtkAssembly.h"
//#include "vtkOBJExporter.h"
//#include "vtkOBJReader.h"
//#include "vtkDataSetMapper.h"
//#include "vtkSelectEnclosedPoints.h"
//#include "vtkMultiThreshold.h"
//#include "vtkNamedColors.h"
//#include "vtkUnstructuredGrid.h"
//#include "vtkMultiBlockDataSet.h"
//#include "vtkAppendFilter.h"
//
//#include <vtkAutoInit.h> 
//VTK_MODULE_INIT(vtkRenderingOpenGL2);
//VTK_MODULE_INIT(vtkInteractionStyle);
//VTK_MODULE_INIT(vtkRenderingFreeType)
//
//using namespace std;
//
//class Branch;
//class Branch
//{
//public:
//	double radius=0;
//	bool isShow = false;
//	vector<Branch> children;
//	vector<int> childenId;
//	int kidLen=0;
//	vector<int> pos;
//	int posLen=0;
//};
//
//vector<Branch> readFileJson();
//vtkSmartPointer<vtkPolyData> ReadPolyData(const char* fileName);
//void myFunc(vtkSmartPointer<vtkPolyData>input1, vtkSmartPointer<vtkPolyData>input2, vtkSmartPointer<vtkRenderer>renderer);
//
//int main(int argc, char *argv[])
//{
//	//渲染场景
//	vtkSmartPointer<vtkRenderer> renderer =
//		vtkSmartPointer<vtkRenderer>::New();
//	vtkSmartPointer<vtkRenderWindow> renderWindow =
//		vtkSmartPointer<vtkRenderWindow>::New();
//	vtkSmartPointer<vtkRenderWindowInteractor> renderWindowInteractor =
//		vtkSmartPointer<vtkRenderWindowInteractor>::New();
//
//	//血管数据
//	vector<Branch> branches = readFileJson();
//
//	//血管模型建立
//	vtkSmartPointer<vtkAssembly> assembly =
//		vtkSmartPointer<vtkAssembly>::New();
//
//	int count = 0;
//	char file[5][100] = {
//		"D:\\Program_Files\\vtk\\vessel_model\\20211122\\vesselkid1",
//		"D:\\Program_Files\\vtk\\vessel_model\\20211122\\vesselkid2",
//		"D:\\Program_Files\\vtk\\vessel_model\\20211122\\vesselkid3",
//		"D:\\Program_Files\\vtk\\vessel_model\\20211122\\vesselkid4",
//		"D:\\Program_Files\\vtk\\vessel_model\\20211122\\vesselkid5"
//	};
//
//	for (int i = 0; i < branches.size(); i++) {
//		if (branches[i].isShow == false) {
//			vtkSmartPointer<vtkPoints> points = vtkSmartPointer<vtkPoints>::New();
//			int indexPos = 0;
//			double rad;
//			vtkSmartPointer<vtkTupleInterpolator> interpolatedRadius =
//				vtkSmartPointer<vtkTupleInterpolator> ::New();
//			interpolatedRadius->SetInterpolationTypeToLinear();
//			interpolatedRadius->SetNumberOfComponents(1);
//			int indexRad = 0;
//			bool flag = true;
//			Branch* target = &branches[i];
//			while (flag) {
//				target->isShow = true;
//				rad = target->radius; interpolatedRadius->AddTuple(indexRad++, &rad);
//				rad = target->radius; interpolatedRadius->AddTuple(indexRad++, &rad);
//				for (int j = 0; j < target->posLen; j += 2) {
//					points->InsertPoint(indexPos++, target->pos[j + 1], target->pos[j], 0);
//				}
//				if (target->kidLen != 0 && branches[target->childenId[0]].isShow == false) {
//					target = &branches[target->childenId[0]];
//				}
//				else {
//					flag = false;
//				}
//			}
//			vtkSmartPointer<vtkParametricSpline> spline = vtkSmartPointer<vtkParametricSpline>::New();
//			spline->SetPoints(points);
//			vtkSmartPointer<vtkParametricFunctionSource> functionSource =
//				vtkSmartPointer<vtkParametricFunctionSource>::New();
//			functionSource->SetParametricFunction(spline);
//			functionSource->SetUResolution(10 * points->GetNumberOfPoints());
//			functionSource->Update();
//
//			vtkSmartPointer<vtkDoubleArray> tubeRadius =
//				vtkSmartPointer<vtkDoubleArray>::New();
//			unsigned int n = functionSource->GetOutput()->GetNumberOfPoints();
//			std::cout << "n:" << n<<" ";
//			tubeRadius->SetNumberOfValues(n);
//			tubeRadius->SetName("TubeRadius");
//			double tMin = interpolatedRadius->GetMinimumT(); std::cout << "tMin:" << tMin << " ";
//			double tMax = interpolatedRadius->GetMaximumT(); std::cout << "tMax:" << tMax << endl;
//			double r;
//			for (unsigned int i = 0; i < n; ++i)
//			{
//				double t = (tMax - tMin) / (n - 1) * i + tMin;
//				interpolatedRadius->InterpolateTuple(t, &r);
//				tubeRadius->SetTuple1(i, r);
//			}
//
//			vtkSmartPointer<vtkPolyData> tubePolyData =
//				vtkSmartPointer<vtkPolyData>::New();
//			tubePolyData = functionSource->GetOutput();
//			tubePolyData->GetPointData()->AddArray(tubeRadius);
//			tubePolyData->GetPointData()->SetActiveScalars("TubeRadius");
//
//			vtkSmartPointer<vtkTubeFilter> tuber =
//				vtkSmartPointer<vtkTubeFilter>::New();
//			tuber->SetInputData(tubePolyData);
//			tuber->SetNumberOfSides(20);
//			tuber->SetVaryRadiusToVaryRadiusByAbsoluteScalar();
//
//			vtkSmartPointer<vtkPolyDataMapper> lineMapper =
//				vtkSmartPointer<vtkPolyDataMapper>::New();
//			lineMapper->SetInputData(tubePolyData);
//			lineMapper->SetScalarRange(tubePolyData->GetScalarRange());
//
//			vtkSmartPointer<vtkPolyDataMapper> tubeMapper =
//				vtkSmartPointer<vtkPolyDataMapper>::New();
//			tubeMapper->SetInputConnection(tuber->GetOutputPort());
//			//tubeMapper->SetScalarRange(tubePolyData->GetScalarRange());
//			tubeMapper->ScalarVisibilityOff();
//
//			vtkSmartPointer<vtkActor> lineActor = vtkSmartPointer<vtkActor>::New();
//			lineActor->SetMapper(lineMapper);
//			vtkSmartPointer<vtkActor> tubeActor = vtkSmartPointer<vtkActor>::New();
//			tubeActor->SetMapper(tubeMapper);
//			//tubeActor->GetProperty()->SetOpacity(0.3);
//			tubeActor->GetProperty()->SetColor(1, 0.09, 0.20);
//			tubeActor->GetProperty()->SetRepresentationToWireframe();
//
//			assembly->AddPart(tubeActor);
//
//			//renderer->AddActor(lineActor);
//			//renderer->AddActor(tubeActor);
//
//			vtkSmartPointer<vtkRenderer> rendererKid =
//				vtkSmartPointer<vtkRenderer>::New();
//			vtkSmartPointer<vtkRenderWindow> renderWindowKid =
//				vtkSmartPointer<vtkRenderWindow>::New();
//			renderWindowKid->AddRenderer(rendererKid);
//			rendererKid->AddActor(tubeActor);
//			vtkSmartPointer<vtkOBJExporter> porterKid = vtkSmartPointer<vtkOBJExporter>::New();
//			porterKid->SetFilePrefix(file[count++]);
//			porterKid->SetInput(renderWindowKid);
//			porterKid->Write();
//		}
//	}
//
//	//renderer->AddActor(assembly);
//	auto polyData1 = ReadPolyData("D:\\Program_Files\\vtk\\vessel_model\\20211122\\vesselKid1.obj");
//	auto polyData2 = ReadPolyData("D:\\Program_Files\\vtk\\vessel_model\\20211122\\vesselKid2.obj");
//	auto polyData3 = ReadPolyData("D:\\Program_Files\\vtk\\vessel_model\\20211122\\vesselKid3.obj");
//	auto polyData4 = ReadPolyData("D:\\Program_Files\\vtk\\vessel_model\\20211122\\vesselKid4.obj");
//	auto polyData5 = ReadPolyData("D:\\Program_Files\\vtk\\vessel_model\\20211122\\vesselKid5.obj");
//
//	myFunc(polyData2, polyData1, renderer);
//	myFunc(polyData3, polyData2, renderer);
//	myFunc(polyData5, polyData3, renderer);
//	myFunc(polyData4, polyData2, renderer);
//
//	vtkSmartPointer<vtkDataSetMapper>appendMapper= vtkSmartPointer<vtkDataSetMapper>::New();
//	appendMapper->SetInputData(polyData1);
//	appendMapper->ScalarVisibilityOff();
//	vtkSmartPointer<vtkActor> appendActor = vtkSmartPointer<vtkActor>::New();
//	appendActor->SetMapper(appendMapper);
//	//appendActor->GetProperty()->SetOpacity(0.3);
//	appendActor->GetProperty()->SetColor(1, 0.09, 0.20);
//	//appendActor->GetProperty()->SetRepresentationToWireframe();
//
//	renderer->AddActor(appendActor);
//
//	vtkSmartPointer<vtkOBJExporter> porter = vtkSmartPointer<vtkOBJExporter>::New();
//	porter->SetFilePrefix("D:\\Program_Files\\vtk\\vessel_model\\20211122\\vessel");
//	porter->SetInput(renderWindow);
//	porter->Write();
//
//	cout << "write complete" << endl;
//
//	renderer->SetBackground(.2, .3, .4);
//	renderWindow->AddRenderer(renderer);
//	renderWindow->SetSize(800, 800);
//	renderWindow->Render();
//	renderWindowInteractor->SetRenderWindow(renderWindow);
//	renderWindowInteractor->Start();
//
//	return EXIT_SUCCESS;
//}
//
//void myFunc(vtkSmartPointer<vtkPolyData>input1, vtkSmartPointer<vtkPolyData>input2, vtkSmartPointer<vtkRenderer>renderer) {
//	vtkNew<vtkSelectEnclosedPoints> select;
//	select->SetInputData(input1);
//	select->SetSurfaceData(input2);
//
//	vtkNew<vtkMultiThreshold> threshold;
//	// Outside points have a 0 value in ALL points of a cell
//	int outsideId = threshold->AddBandpassIntervalSet(
//		0, 0, vtkDataObject::FIELD_ASSOCIATION_POINTS, "SelectedPoints", 0, 1);
//	// Inside points have a 1 value in ALL points of a cell
//	int insideId = threshold->AddBandpassIntervalSet(
//		1, 1, vtkDataObject::FIELD_ASSOCIATION_POINTS, "SelectedPoints", 0, 1);
//	// Border points have a 0 or a 1 in at least one point of a cell
//	int borderId = threshold->AddIntervalSet(
//		0, 1, vtkMultiThreshold::OPEN, vtkMultiThreshold::OPEN,
//		vtkDataObject::FIELD_ASSOCIATION_POINTS, "SelectedPoints", 0, 0);
//
//	threshold->SetInputConnection(select->GetOutputPort());
//
//	// Select the intervals to be output
//	threshold->OutputSet(outsideId);
//	threshold->OutputSet(insideId);
//	threshold->OutputSet(borderId);
//	threshold->Update();
//
//
//	// Visualize
//	vtkNew<vtkNamedColors> colors;
//	vtkColor3d outsideColor = colors->GetColor3d("Crimson");
//	vtkColor3d insideColor = colors->GetColor3d("Banana");
//	vtkColor3d borderColor = colors->GetColor3d("Crimson");
//	vtkColor3d surfaceColor = colors->GetColor3d("Peacock");
//	vtkColor3d backgroundColor = colors->GetColor3d("Silver");
//
//	// Outside
//	vtkSmartPointer<vtkDataSetMapper> outsideMapper= vtkSmartPointer<vtkDataSetMapper>::New();
//	outsideMapper->SetInputData(dynamic_cast<vtkUnstructuredGrid*>(
//		vtkMultiBlockDataSet::SafeDownCast(
//			threshold->GetOutput()->GetBlock(outsideId))
//		->GetBlock(0)));
//	outsideMapper->ScalarVisibilityOff();
//	vtkSmartPointer<vtkActor> outsideActor= vtkSmartPointer<vtkActor>::New();
//	outsideActor->SetMapper(outsideMapper);
//	outsideActor->GetProperty()->SetColor(1, 0.09, 0.20);
//	/*outsideActor->GetProperty()->SetDiffuseColor(outsideColor.GetData());
//	outsideActor->GetProperty()->SetSpecular(.6);
//	outsideActor->GetProperty()->SetSpecularPower(30);*/
//	//outsideActor->GetProperty()->SetOpacity(.1);
//	//outsideActor->GetProperty()->SetRepresentationToWireframe();
//
//	// Inside
//	vtkNew<vtkDataSetMapper> insideMapper;
//	insideMapper->SetInputData(dynamic_cast<vtkUnstructuredGrid*>(
//		vtkMultiBlockDataSet::SafeDownCast(
//			threshold->GetOutput()->GetBlock(insideId))
//		->GetBlock(0)));
//	insideMapper->ScalarVisibilityOff();
//	vtkNew<vtkActor> insideActor;
//	insideActor->SetMapper(insideMapper);
//	insideActor->GetProperty()->SetDiffuseColor(insideColor.GetData());
//	insideActor->GetProperty()->SetSpecular(.6);
//	insideActor->GetProperty()->SetSpecularPower(30);
//	insideActor->GetProperty()->EdgeVisibilityOn();
//	insideActor->GetProperty()->SetOpacity(0);
//	insideActor->GetProperty()->SetRepresentationToWireframe();
//
//	// Border
//	vtkSmartPointer<vtkDataSetMapper> borderMapper= vtkSmartPointer<vtkDataSetMapper>::New();
//	borderMapper->SetInputData(dynamic_cast<vtkUnstructuredGrid*>(
//		vtkMultiBlockDataSet::SafeDownCast(
//			threshold->GetOutput()->GetBlock(borderId))
//		->GetBlock(0)));
//	borderMapper->ScalarVisibilityOff();
//	vtkSmartPointer<vtkActor> borderActor= vtkSmartPointer<vtkActor>::New();
//	borderActor->SetMapper(borderMapper);
//	borderActor->GetProperty()->SetColor(1, 0.09, 0.20);
//	/*borderActor->GetProperty()->SetDiffuseColor(borderColor.GetData());
//	borderActor->GetProperty()->SetSpecular(.6);
//	borderActor->GetProperty()->SetSpecularPower(30);
//	borderActor->GetProperty()->EdgeVisibilityOn();*/
//	//borderActor->GetProperty()->SetOpacity(0);
//	//borderActor->GetProperty()->SetRepresentationToWireframe();
//
//	vtkNew<vtkDataSetMapper> surfaceMapper;
//	surfaceMapper->SetInputData(input2);
//	surfaceMapper->ScalarVisibilityOff();
//	// Surface of object containing cell
//	vtkNew<vtkActor> surfaceActor;
//	surfaceActor->SetMapper(surfaceMapper);
//	surfaceActor->GetProperty()->SetDiffuseColor(surfaceColor.GetData());
//	surfaceActor->GetProperty()->SetOpacity(.1);
//	//surfaceActor->GetProperty()->SetRepresentationToWireframe();
//
//
//	//renderer->AddActor(surfaceActor);
//	renderer->AddActor(outsideActor);
//	//renderer->AddActor(insideActor);
//	renderer->AddActor(borderActor);
//
//}
//
//vector<Branch> readFileJson()
//{
//	Json::Reader reader;
//	Json::Value root;
//
//	vector<Branch> tempbranches;
//
//	//从文件中读取，保证当前文件有branches.json文件  
//	ifstream in("D:\\Program_Files\\OpenCV\\Projects\\OpenCVTest1Img\\branches.json", ios::binary);
//
//	if (!in.is_open())
//	{
//		cout << "Error opening file\n";
//		return tempbranches;
//	}
//
//	if (reader.parse(in, root))
//	{
//		//读取数组信息  
//		int numBranch = root["lines"].size();
//		vector<Branch> branches(numBranch);
//
//		for (unsigned int i = 0; i < numBranch; i++)
//		{
//			//cout << root["lines"][i] << endl;
//			Branch node;
//			int len = root["lines"][i].size() ;
//			//step为取关键点的步长，step越小，血管走势越精确
//			int step = 30;
//			int newlen = 0;
//			int j1 = 0;
//			//newlen为关键点坐标长度。因为测试数据为二维所以只有x,y两个坐标每次取坐标长度+2
//			for (j1; j1 < len; j1 += step) {
//				newlen += 2;
//			}
//			//确保关键点数据包含血管首尾
//			if (j1 - 10 != len - 1) {
//				newlen += 2;
//			}
//			node.posLen = newlen;
//			vector<int> p(newlen);
//			int index = 0;
//			int j = 0;
//			for (j; j < len; j += step) {
//				for (int k = 0; k < root["lines"][i][j].size(); k++) {
//						p[index++] = root["lines"][i][j][k].asInt();
//				}
//			}
//			if (j - 10 != len - 1) {
//				for (int k = 0; k < root["lines"][i][len - 1].size(); k++) {
//					p[index++] = root["lines"][i][len - 1][k].asInt();
//				}
//			}
//			node.pos = p;
//			branches[i]=node;
//		}
//
//		for (int i = 0; i < numBranch; i++) {
//			int s = branches[i].posLen;
//			int kidlen = 0;
//			for (int j = 0; j < numBranch; j++) {
//				//判断是否为该段血管的子血管
//				if (j != i && s > 2 &&
//					(branches[j].pos[0] >= branches[i].pos[s - 2] - 5) &&
//					(branches[j].pos[0] <= branches[i].pos[s - 2] + 5) &&
//					(branches[j].pos[1] >= branches[i].pos[s - 1] - 5) &&
//					(branches[j].pos[1] <= branches[i].pos[s - 1] + 5))
//				{
//					kidlen++;
//					branches[i].children.push_back(branches[j]);
//					branches[i].childenId.push_back(j);
//				}
//			}
//			branches[i].kidLen = kidlen;
//			if (kidlen > 0) {
//				branches[i].posLen -= 2;
//			}
//		}
//
//		//应该设置用户输入或者算法计算，这里直接简单设置
//		branches[0].radius = 20;
//		branches[1].radius = 15;
//		branches[2].radius = 15;
//		branches[3].radius = 11.25;
//		branches[4].radius = 8.4375;
//		branches[5].radius = 11.25;
//		branches[6].radius = 8.4375;
//		branches[7].radius = 8.4375;
//		branches[8].radius = 8.4375;
//
//		//一个计算子血管段半径的简单方法
//		/*for (int i = 0; i < numBranch; i++) {
//			int numKid = branches[i].kidLen;
//			for (int j = 0; j < numKid; j++) {
//				branches[i].children[j].radius = branches[i].radius / numKid*1.5;
//			}
//		}*/
//
//		cout << "Reading Complete!" << endl;
//		return branches;
//	}
//	else
//	{
//		cout << "parse error\n" << endl;
//	}
//
//	in.close();
//
//	return tempbranches;
//}
//
//vtkSmartPointer<vtkPolyData> ReadPolyData(const char* fileName)
//{
//	vtkSmartPointer<vtkPolyData> polyData;
//	vtkNew<vtkOBJReader> reader;
//	reader->SetFileName(fileName);
//	reader->Update();
//	polyData = reader->GetOutput();
//	return polyData;
//}