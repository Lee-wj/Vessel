//#include <vtkActor.h>
//#include <vtkCamera.h>
//#include <vtkCellCenters.h>
//#include <vtkGlyph3DMapper.h>
//#include <vtkNamedColors.h>
//#include <vtkNew.h>
//#include <vtkPolyDataMapper.h>
//#include <vtkProperty.h>
//#include <vtkRenderWindow.h>
//#include <vtkRenderWindowInteractor.h>
//#include <vtkRenderer.h>
//#include <vtkSmartPointer.h>
//
//#include <vtkBYUReader.h>
//#include <vtkOBJReader.h>
//#include <vtkPLYReader.h>
//#include <vtkPolyDataReader.h>
//#include <vtkSTLReader.h>
//#include <vtkSphereSource.h>
//#include <vtkXMLPolyDataReader.h>
//#include <vtksys/SystemTools.hxx>
//#include <vtkColor.h>
//#include <vtkNamedColors.h>
//#include <vtkSphereSource.h>
//#include <vtkCellLocator.h>
//#include <vtkPolyDataConnectivityFilter.h>
//
//#include <algorithm>
//#include <vector>
//
//#include <vtkAutoInit.h> 
//VTK_MODULE_INIT(vtkRenderingOpenGL2);
//VTK_MODULE_INIT(vtkInteractionStyle);
//VTK_MODULE_INIT(vtkRenderingFreeType)
//
//namespace {
//	vtkSmartPointer<vtkPolyData> ReadPolyData(const char* fileName);
//}
//
//int main(int argc, char* argv[])
//{
//	// Read the polydata
//	auto polyData = ReadPolyData(argc > 1 ? argv[1] : "D:\\Program_Files\\vtk\\vessel_model\\vesselKid2.obj");
//	/*vtkNew<vtkPolyDataMapper> mapper;
//	mapper->SetInputData(polyData);
//	vtkNew<vtkActor> actor;
//	actor->SetMapper(mapper);*/
//
//	double center[3], bounds[6];
//	polyData->GetCenter(center);
//	polyData->GetPoints()->GetBounds(bounds);
//
//	// Build a cell locator.
//	vtkNew<vtkCellLocator> cellLocator;
//	cellLocator->SetDataSet(polyData);
//	cellLocator->BuildLocator();
//
//	// Now fire a ray from outside the bounds to the center and find a
//	// cell. This cell should be on the outside surface
//	double rayStart[3];
//	for (unsigned int i = 0; i < 3; i++)
//	{
//		rayStart[i] = bounds[2 * i + 1] * 1.1;
//	}
//
//	vtkIdType cellId = -1;
//	double xyz[3], t, pcoords[3];
//	int subId;
//
//	cellLocator->IntersectWithLine(rayStart, center, 0.0001, t, xyz, pcoords,
//		subId, cellId);
//	std::cout << "Id of cell on outside surface: " << cellId << std::endl;
//
//	vtkNew<vtkPolyDataConnectivityFilter> connectivityFilter;
//	connectivityFilter->SetInputData(polyData);
//	connectivityFilter->SetExtractionModeToCellSeededRegions();
//	connectivityFilter->InitializeSeedList();
//	connectivityFilter->AddSeed(cellId);
//
//	// Create a mapper and actor for original data
//	vtkNew<vtkPolyDataMapper> originalMapper;
//	originalMapper->SetInputData(polyData);
//
//	vtkNew<vtkNamedColors> colors;
//
//	vtkNew<vtkActor> originalActor;
//	originalActor->SetMapper(originalMapper);
//	originalActor->GetProperty()->BackfaceCullingOn();
//	originalActor->GetProperty()->SetOpacity(0.6);
//	originalActor->GetProperty()->SetColor(colors->GetColor3d("Gold").GetData());
//
//	// Create a mapper and actor for extracted data
//	vtkNew<vtkPolyDataMapper> extractedMapper;
//	extractedMapper->SetInputConnection(connectivityFilter->GetOutputPort());
//
//	vtkNew<vtkActor> extractedActor;
//	extractedActor->GetProperty()->SetColor(
//		colors->GetColor3d("Peacock").GetData());
//	extractedActor->SetMapper(extractedMapper);
//	extractedActor->GetProperty()->SetOpacity(0.6);
//	extractedActor->GetProperty()->BackfaceCullingOn();
//
//	// Setup render window, renderer, and interactor
//	// Create a renderer
//	vtkNew<vtkRenderer> renderer;
//	renderer->AddActor(originalActor);
//	renderer->AddActor(extractedActor);
//
//	renderer->GradientBackgroundOn();
//	renderer->SetBackground2(colors->GetColor3d("Beige").GetData());
//	renderer->SetBackground(colors->GetColor3d("DarkSlateGray").GetData());
//
//	extractedActor->SetPosition((bounds[1] - bounds[0]) / 1.9, 0, 0);
//	originalActor->SetPosition(-(bounds[1] - bounds[0]) / 1.9, 0, 0);
//	// Create a render window
//	vtkNew<vtkRenderWindow> renwin;
//	renwin->AddRenderer(renderer);
//	renwin->SetSize(512, 512);
//	renwin->SetWindowName("ExtractOutsideSurface");
//
//	// Create an interactor
//	vtkNew<vtkRenderWindowInteractor> iren;
//	iren->SetRenderWindow(renwin);
//	renwin->Render();
//	iren->Initialize();
//	iren->Start();
//
//	return EXIT_SUCCESS;
//}
//
//namespace {
//	vtkSmartPointer<vtkPolyData> ReadPolyData(const char* fileName)
//	{
//		vtkSmartPointer<vtkPolyData> polyData;
//		std::string extension =
//			vtksys::SystemTools::GetFilenameExtension(std::string(fileName));
//		if (extension == ".ply")
//		{
//			vtkNew<vtkPLYReader> reader;
//			reader->SetFileName(fileName);
//			reader->Update();
//			polyData = reader->GetOutput();
//		}
//		else if (extension == ".vtp")
//		{
//			vtkNew<vtkXMLPolyDataReader> reader;
//			reader->SetFileName(fileName);
//			reader->Update();
//			polyData = reader->GetOutput();
//		}
//		else if (extension == ".obj")
//		{
//			vtkNew<vtkOBJReader> reader;
//			reader->SetFileName(fileName);
//			reader->Update();
//			polyData = reader->GetOutput();
//		}
//		else if (extension == ".stl")
//		{
//			vtkNew<vtkSTLReader> reader;
//			reader->SetFileName(fileName);
//			reader->Update();
//			polyData = reader->GetOutput();
//		}
//		else if (extension == ".vtk")
//		{
//			vtkNew<vtkPolyDataReader> reader;
//			reader->SetFileName(fileName);
//			reader->Update();
//			polyData = reader->GetOutput();
//		}
//		else if (extension == ".g")
//		{
//			vtkNew<vtkBYUReader> reader;
//			reader->SetGeometryFileName(fileName);
//			reader->Update();
//			polyData = reader->GetOutput();
//		}
//		else
//		{
//			vtkNew<vtkSphereSource> source;
//			source->Update();
//			polyData = source->GetOutput();
//		}
//		return polyData;
//	}
//} // namespace